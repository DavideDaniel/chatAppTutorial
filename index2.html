<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<title>ChatApp Tutorial</title>
    <!-- Bootstrap -->
    <link href="dist/css/bootstrap.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
<body>

<!-- <div class = "sidepanel"> -->

<div class="nav_menu">
  <div class="step top">Git Repos</div>
  <div class="step inner">GitHub</div>
  <div class="step inner">Server Side</div>
  <div class="step inner">Client Side</div>
  <div class="step inner">Testing Locally</div>
  <div class="step inner">Styling</div>
  <div class="step bottom">Hosting</div>
</div>





<xmp theme="cerulean" style="display:none;">
####[Intro](#1) | [Git repos](#2) | [GitHub](#2) | [Server side](#3) | [Client side](#chapter4) | [Testing locally](#5) | [Styling](#chapter-6) [Hosting](#chapter-7)   


---

#Chat App Tutorial
---

<h2 id = "1">Build your own chat app!</h3>


If you'd like to create the next SnapChat, proceed. 

If you'd like to be the creator of a new and improved SnapChat, read on. 

You still there? Awesome. Thanks for checking out our tutorial! 

Today you'll learn how to create your first functional, peer to peer, chat app. For many beginner JavaScript developers, building one of these has become somewhat of a rite of passage so congratulations, welcome to the club. Chatapp projects are a good place to test your budding Javascript skills because it's framework comprise of complex yet accessible parts. 

Here, we'll show you the basic framework. And from the framework, we'll go on to teach you how to style, test, and host your site! Sounds like a lot right? Don't panic, youre in good hand. By the end of our tutorial, you'll be able to build features that go above and beyond the SnapChat-standard.

We'll teach you what a server and client does and of course give you instruction on the code to make the server and client connect with each other.

By the end you will have learned: how to create a server and client, how to get them communicating with each other, how to style the app, how to test it, how to host it, and finally,  how to impress the internet by pushing your code to Github.

###WebSockets

Needs content

###JSON (but keeping it simple for now)

Needs content

---
#Git & Github

<h3 id = "2">Creating a Git Repository</h3>

The git init command creates a new Git repository. It can be used to convert an existing, unversioned project to a Git repository or initialize a new empty repository. Most of the other Git commands are not available outside of an initialized repository, so this is usually the first command you’ll run in a new project.

The git clone command copies an existing Git repository. This is sort of like svn checkout, except the “working copy” is a full-fledged Git repository—it has its own history, manages its own files, and is a completely isolated environment from the original repository.

The git config command lets you configure your Git installation (or an individual repository) from the command line. This command can define everything from user info to preferences to the behavior of a repository. Several common configuration options are listed below. 

Linktos or Asides or Syntax Bubble:

Executing git init creates a .git subdirectory in the project root, which contains all of the necessary metadata for the repo, and makes it possible to start recording revisions of the project.. 

```
    $ git clone <repository link>
```
Clone the repository located at <repo> onto the local machine. The original repository can be located on the local filesystem or on a remote machine accessible via HTTP or SSH.

To update your local repository to the newest commit, execute git pull in your working directory to fetch and merge remote changes. 


### Version control with Github
---

Assuming you've already created a folder inside your text editor. Now its time to create a github repo and push to github. 

1. Navigate to the working directory 

  ```
  $ cd tutorialChatApp
  ```
2. Check status & proceed

  ```
  $ git status
  ```

3. Add any changes - note `add .` will add all but you can also specify files

  ```
  $ git add .
  ```
4. Commit your changes - whatever you write here will help in tracking changes

  ```
  $ git commit -m "First commit"

  ```
  Your changes are now in your local working copy

5. Push up to git via https (not SSH)- granted you have no troubles with your log in. Make sure 

  ```
  $ git push origin master

  ```

<h3 id = "3">Server side</h3>

A websocket server can receive and send data among multiple clients, and
is necessary to host your chat app. The purpose of this server is to
relay messages,  This code will require several crucial lines of code,
but additional features can be added to make your chat app more robust.

1. First, the ws module must be required.
<pre class="prettyprint">
var WebSocket = require("ws").Server;
var chatServer = new WebSocket({port:3000});
</pre>
Note that the Server method is necessary when requiring ws for the
purpose of creating a server. A port number of your choice should be
declared, but it must consistent across future code in order for the
server and clients to interact.

2. An empty array should be created to track clients connecting to the
server. This will allow the server to send information to multiple
clients at once.
<pre class="prettyprint">
var users = [];
</pre>

3. Event listeners are added to the server in order to define how it
handles connections and messages.

<pre class="prettyprint">
chatServer.on("connection" , function(ws){
  console.log("connection");
  users.push(ws);
}
</pre>
The above code adds every connecting client to the users array, and
console logs a simple message that will help you monitor /test
functionality. Nested within the above function, you must also add
event listeners to the clients, which are defined above by the ws parameter.

<pre class="prettyprint">
  ws.on("message" , function(msg){
    console.log(msg);
    users.forEach(function(usr){usr.send(msg)});
  })
</pre>
4. Every time there is a message event, the above code will log that
message on the server console, and send the message to every user in the
users array, including the original sender.

5. This next step is virtually essential. In the event a client disconnects,
any attempt the server makes to send a message will cause it to crash.
We must add another event listener to the client that will remove it
from the users array on a close event.

<pre class="prettyprint">
  ws.on("close" , function(){
      var clientIndex = users.indexOf(ws);
      users.splice(clientIndex,1);
      console.log("a client has disconnected");
  })
</pre>
Every time a client disconnects, the above code finds the index of that
client with the users array, and then deletes their information from the
array. This code in its current state is completely usable for the purpose
of serving a simple chat app.

<pre class="prettyprint">
  var WebSocket = require("ws").Server;
  var chatServ = new WebSocket({port:3000});
  var users = [];

  chatServ.on("connection" , function(ws){
    console.log("connection");
    users.push(ws);

    ws.on("message" , function(msg){
      console.log(msg);
      users.forEach(function(usr){usr.send(msg)});
    })

    ws.on("close" , function(){
      var client = users.indexOf(ws);
      users.splice(client,1);
      console.log("a client has disconnected");
    })

  })
</pre>

Other possible features you might want to consider adding to your app are
a persistent message history, private messages between users, and word filtering
functions. Incorporating JSON into your code will allow you to package more
information in every message beyond simple strings.

</span>

</div>

<h3 id = "4">Client Side</h3>

####HTML file

Let's make a barebones HTML file that'll allow us to use the client for the chat app.


```html
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!-- link to style sheet - we'll get to this later! -->
        <link rel="stylesheet" type="text/css" href="tutorialStyle.css">

        <title>Chat</title>

    </head>
    <body>
        <!-- In the beginning there was a div for the header -->
        <div class="header">
            <h2>Chat App</h2>
        </div>

        <!-- But! Here's a div that binds them all! -->
        <div class="container">
            <!-- and in the darkness... presents the message... -->
            <div id="inset">
                <!-- but first this div collects your name! -->
                <div id = "fixed">
                    <p id="enter"> Please enter your screen name:</p></br>
                    <input type="text" id="inputOne" placeholder="Name"></input>
                </div>

                <ul id="msgHolder"></ul>

            </div>
        </div>
        
        <!-- This div holds the input box -->
        <div class="bottom">
            <!-- <div class="bottom"> -->
                <input placeholder="Type here" id="inputMsg"></input>
            <!-- </div> -->
        </div>



<script type="text/javascript" src="tutorialclient.js"></script>
</body>
</html>


###Client JS file

In order for the client to connect to the server we'll want to set up some variables.

1. Establish a new Websocket client. Remember to be explicit in naming your variables!

  var client = new WebSocket( "ws://localhost:3000" );


2. Let's say that our client is going to log in and have a name. But prior to connecting the name will be a string that is empty.

    ```javascript
    var userName = '';
    var connected = true;
    ```

3. Let's setup event listeners for the client to determine what's happening.


  
    client.addEventListener( 'open', function ( evt ) {
    } );

    client.addEventListener( 'message', function ( message ) {
    } )

    client.addEventListener( 'close', function ( evt ) {
    } );



4. Now to get more detailed...    

    Upon connecting ('open') we want the client to set their name. In order to do this, let's have them send a message that changes their `userName` value. We'll utilize DOM manipulation and a keyboard event listener to do that.
    
```javascript    

// upon open
     client.addEventListener( 'open', function () {
         // grab inputTwo
         var inputTwo = document.getElementById( 'inputTwo' )
         // event listener on inputTwo
         inputTwo.addEventListener( 'keyup', function ( e ) {
             // if enter is pressed and the box is NOT empty
             if ( e.keyCode === 13 && inputOne.value.trim() != '' ) { 
                 // set the userName value...
                 var fixedDiv = document.querySelector( '#fixed' )
                 userName = inputOne.value;
                // and grab the fixedDiv and set it's style to make it disappear!
                fixedDiv.style.display = 'none';
            }
        } );
    } );
```


5. Now that we've set our client's name upon connect, let's tackle what happens when we recieve a message.
    

    // upon recieving a message
      client.addEventListener( 'message', function ( message ) {

        //create an li element
        var li = document.createElement( "li" );
        // change it's innerText value to the recieved message
        li.innerText = input.value;
        // set it's id to 'msg'
        li.setAttribute( 'id', 'msg' )
        // grab the ul element      
        var msgHolder = document.querySelector( "ul#msgHolder" );
        // and append it to include the new li
        msgHolder.appendChild( li );
        // then have it display BEFORE the newest element
        var before = ul.firstChild;
        ul.insertBefore( li, before )

    } );
```

6. While we're not doing anything complex yet, you can certainly have events occur upon close. Let's make a couple edits to display this.
    
    We'll add a boolean to the file
    ```javascript
    var userName = '';
    var connected = false; //set to false by default
    ```

    and have it return true upon connect
    ```javascript
    client.addEventListener( 'open', function () {
        connected = true;
    ```

    and have it return back to false upon close!
    ```javascript
    client.addEventListener( 'close', function () {
        connected = false;
    ```
While not necessary in our tutorial app, just note that it's possible to have events occur on the client side but you can't send anything to the server upon close.

7. BUT WAIT! How on earth do we send messages?!!
    Well.. there's an app for that...
    But seriously...
    We've already done it upon connection so let's make another event listener.
  
      ```javascript
      // grab the inputMsg element
      var inputMsg = document.getElementById( 'inputMsg' )
  
      inputMsg.addEventListener( 'keyup', function ( e ) {
          // upon pressing enter
          if ( e.keyCode === 13 ) {
              // grab the text in the input box and call it newMessage
              var newMessage = input.value;
              // with the .send method let's format and send our name & message
              client.send( userName + ': ' + newMessage );
              // finally, let's clear the input box
              input.value = ''; //clear the input area
          }
      } );
      ```


  And now you have a functional frontend JS file for your client!
  
##Styling
---
##Styling the app



###CSS 

We'll reference our HTML file here a few times so for the whole code, please refer to [clientSteps link here eventually](clientsteps link here)


####Divs Divs Divs

In order for us to have a responsive (and what other way is there to be?!) design let's start with some givens.

1. Flexbox [link to flex](link here)
    This alone will make your CSS life easier
2. Use percentages and vh instead of fixed pixels when able to in order to have a relative design. [provide links on the side to responsive design]
    With the following snippet in your header you're establishing that the width of the content will be the device width, and with percentages you should be able to have easy responsive design.
```html
    <meta name="viewport" content="width=device-width, initial-scale=1">
```
3. Framework your design, whether by hand, inDesign, photoshop or just with divs alone before you start so you have a path.
[more links](links)
4. A good tip to remember while working with divs is to give them all different colored borders so you can tell where they are exactly and help you position them as well. This is espescially convenient when planning to make your site responsive. For example here are 2 divs that we'll be working on:
```CSS

div.container {
    border: thin solid black;
    height: 80%;
    width: 80%;
    margin: auto;
}

.bottom {
    border: thin solid orange;
    height: 40px;
    width: 80%;
    margin: auto;
}
```



---
Keeping it simple, we're going to do our work with divs here.

####Creating the CSS file
1. So we've set up all our divs now:


    div.container {
        border: thin solid black;
        height: 80%; /* set to 80% of the body */
        width: 80%; /* set to 80% of the window */
        display: flex;
        margin: auto;
    }
    
    div#fixed {
        border: thin solid black;
        min-height: 10vh; /* vh is viewport height - this says 10% of vh
        margin: auto;
        text-align: center;
        padding: 2%;
        overflow: auto;
    }
    
    div#inset {
        border: thin solid red;
        height: 100%;
        width: 100%;
        min-width: 30vh;
        overflow: auto;
        align-self: center;
        display: flex;
        flex-direction: column-reverse;
    }
    
    div.bottom {
        display: flex;
        border: thin solid orange;
        height: 40px; 
        width: 80%;
        display: flex;
        margin: auto;
        font-size: 1.25em; 
    }


1. Let's first set the font-family for the whole app. We've chosen Helvetica with arial as a backup incase Helvetica isn't available for some reason. 

    * {
        font-family: Helvetica, arial;
      }


2. Now let's work from the top down. First we'll style the header:


    .header {
        background-color: #999; 
        font-size: 100%;    /*set the font-size to 100% (note the %)*/
        text-align: center; 
        width: 50%; /* we'll establish the width at 50%*/
        m
        argin-left: 25%; /* as we've set the width to 50% we can set the margin-left at                   25% thereby centering the element*/
}



</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="dist/js/bootstrap.min.js"></script>
  </body>
</html>
